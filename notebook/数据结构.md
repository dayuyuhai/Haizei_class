#  Preface

## æ•°æ®ç»“æ„

- å¸®æˆ‘ä»¬è§£å†³ç©ºé—´ä¸Šçš„åˆç†è¿ç”¨

- æ•°æ®ç»“æ„ = ç»“æ„å®šä¹‰ + ç»“æ„æ“ä½œ / å®šä¹‰ä¸€ç§æ€§è´¨å¹¶ç»´æŠ¤ä¸€ä¸ªæ€§è´¨ï¼ˆå¦‚å †ï¼‰

- ç¨‹åºå†…éƒ¨å’Œå†…å­˜å†…éƒ¨


![Screenshot from 2020-06-06 19-20-36](/home/waygu-beef/å›¾ç‰‡/Screenshot from 2020-06-06 19-20-36.png)



##  å†™åœ¨å‰é¢

###  å…³äºåˆ é™¤

åˆ é™¤åªæ˜¯è¯´æ˜è¯¥ä½ç½®å¯ä»¥è¢«è¦†ç›–ï¼Œå’Œæ–‡ä»¶åˆ é™¤ä¸€æ ·ï¼Œå‘Šè¯‰æ“ä½œç³»ç»Ÿè¿™å—åœ°æ–¹å¯ä»¥è¢«è¦†ç›–ï¼Œæ ¹æ®ä¸€äº›æ•°æ®ç»“æ„çš„å…·ä½“å®ç°è‡ªå·±ä½“ä¼šã€‚



###  ä¸»å‡½æ•°æµ‹è¯•åŠŸèƒ½çš„ä¸€äº›å¤„ç†

```c
#include<time.h>  
int main() {
	srand(time(0));         // ä¸ºäº†éšæœºç”Ÿæˆæ’å…¥ä½ç½®ã€æ’å…¥å€¼ç­‰å€¼
    #define max_op 20       // å®šä¹‰æœ€å¤§æ“ä½œæ•°
	Vector *vec = init(max_op / 4);
	for (int i = 0; i < max_op; i++) {
		int op = rand() % 4;
		int ind = rand() % (vec->length + 3) - 1;
		int val = rand() % 100;

```

```c
		switch (op) {
			case 0:         // æ§åˆ¶æœ‰å››åˆ†ä¹‹ä¸‰çš„æ¦‚è®ºæ‰§è¡Œæ’å…¥
			case 1:
			case 2: {
				printf("insert %d at %d to Vector = %d\n", val, ind, insert(vec, ind, val));     // è¾“å‡ºæ ¼å¼
			} break;
			case 3: {
				printf("erase a item at %d from Vector = %d\n", ind, erase(vec, ind));
			} break;
		}

```



###  init()

å°†ç»“æ„å®šä¹‰ä¸­çš„æ¯ä¸€ä¸ªæˆå‘˜éƒ½åˆå§‹åŒ–



###  ä¸‰ä¸ªå¼€è¾Ÿå†…å­˜ç©ºé—´çš„æ–¹å¼

1. malloc   è¿”å›å¼€è¾Ÿç©ºé—´çš„é¦–åœ°å€
2. calloc   å¼€è¾Ÿç©ºé—´ï¼Œå¹¶éƒ½æ¸…ç©ºä¸º0
3. realloc  é‡æ–°å¼€è¾Ÿç©ºé—´ï¼Œå…ˆçœ‹å½“å‰åœ°å€åé¢å¤Ÿä¸å¤Ÿå¼€ï¼Œä¸å¤Ÿå°±ä»å†…å­˜æ¢ä¸€ä¸ªåœ°æ–¹åˆ†é…ç©ºé—´ï¼Œä¹‹å‰æ•°æ®æ‹·è´è¿‡å»ã€‚å¦‚æœå†…å­˜å“ªå“ªéƒ½æ²¡åœ°æ–¹ï¼Œè¿”å›NULLï¼Œå¯èƒ½é€ æˆå†…å­˜æ³„éœ²å’ŒåŸæ•°æ®ä¸¢å¤±,é¿å…æ–¹æ³•è§é¡ºåºè¡¨æ‰©å®¹æ“ä½œ



###  å…³äºå†…å­˜æ³„éœ²

æ“ä½œç³»ç»Ÿä»¥ä¸ºå†…å­˜å±äºä½ ï¼Œä½†æ˜¯ä½ å·²ç»è®¿é—®ä¸åˆ°äº†ã€‚å¦‚é“¾è¡¨æ’å…¥æ—¶ï¼Œå‰é¢èŠ‚ç‚¹ç›´æ¥æŒ‡å‘ä»£æ’å…¥èŠ‚ç‚¹ï¼Œå®ƒåé¢çš„æ•°æ®å°±èµ°ä¸¢äº†ï¼Œè¢«å­¤é›¶é›¶çš„ç•™åœ¨å†…å­˜é‡Œï¼Œå åœ°æ–¹è¿˜æ²¡äººè¦



###  æ™ºèƒ½æŒ‡é’ˆ

æ­£å¸¸æŒ‡é’ˆï¼šå‡ ä¸ªæŒ‡é’ˆæŒ‡å‘é‚£ä¸ªåœ°æ–¹ï¼Œæœ‰ä¸€ä¸ªé‡Šæ”¾äº†ï¼Œæ“ä½œç³»ç»Ÿå°±å›æ”¶ï¼Œå¤§å®¶å°±éƒ½ä¸è¦å®ƒäº†

æ™ºèƒ½æŒ‡é’ˆï¼šc++çš„ï¼Œæ‰€æœ‰è®°å¾—å®ƒçš„æŒ‡é’ˆéƒ½èµ°äº†ï¼Œå®ƒæ‰è¢«æ°¸è¿œé—å¿˜



#  First é¡ºåºè¡¨

##  ç»“æ„å®šä¹‰

```c
size
length
data_type = XXX
//xxx:ä»»æ„ç±»å‹
```

##  ç»“æ„æ“ä½œ

###  æ’å…¥

length++

```c
int insert(Vector *vec, int ind, int val) {
	if (vec == NULL) return 0;
	if (ind < 0 || ind > vec->length) return 0;
	if (vec->length == vec->size) {
		if (!expand(vec)) return 0;
		printf("success to expand ! the Vector size is %d\n", vec->size);
	}
	for (int i = vec->length; i > ind; i--) {
		vec->data[i] = vec->data[i - 1];
	}
	vec->data[ind] = val;
	vec->length += 1;
	return 1;
}
```



###  åˆ é™¤

length--

```c
int erase(Vector *vec, int ind) {
	if (vec == NULL) return 0;
	if (ind < 0 || ind >= vec->length) return 0;
	for (int i = ind + 1; i < vec->length; i++) {
		vec->data[i - 1] = vec->data[i];
	}
	vec->length -= 1;
	return 1;
}
```



###  æ‰©å®¹

```c
int expand(Vector *vec) {
	//vec->size *= 2;
	//vec->data = (int *)realloc(vec->data, sizeof(int) * vec->size)
    //å¼€è¾Ÿå¤±è´¥(å†…å­˜å“ªå“ªéƒ½æ²¡åœ°æ–¹)è¿”å›NULLï¼Œä¼šå†…å­˜æ³„æ¼,åŸæ¥çš„æ•°æ®æ‰¾ä¸åˆ°äº†
	int extr_size = vec->size;
	int *p;
	while (extr_size) {
		p = (int *)realloc(vec->data, sizeof(int) * (vec->size + extr_size));
		if (p) break;
		extr_size /= 2;
	}
	if (extr_size == 0) return 0;
	vec->data = p;
	vec->size += extr_size;
	return 1;
}
```





##  ä»£ç å®ç°

```c
#include<iostream>
#include<stdlib.h>
#include<time.h>
using namespace std;

typedef struct Vector {
	int *data;
	int size, length;
} Vector;

Vector *init(int n) {
	Vector *vec = (Vector *) malloc(sizeof(Vector));
	vec->data = (int *)malloc(n * sizeof(int));
	vec->size = n;
	vec->length = 0;
	return vec;
}

int expand(Vector *vec) {
	int extr_size = vec->size;
	int *p;
	while (extr_size) {
		p = (int *)realloc(vec->data, sizeof(int) * (vec->size + extr_size));
		if (p) break;
		extr_size /= 2;
	}
	if (extr_size == 0) return 0;
	vec->data = p;
	vec->size += extr_size;
	return 1;
}


int insert(Vector *vec, int ind, int val) {
	if (vec == NULL) return 0;
	if (ind < 0 || ind > vec->length) return 0;
	if (vec->length == vec->size) {
		if (!expand(vec)) return 0;
		printf("success to expand ! the Vector size is %d\n", vec->size);
	}
	for (int i = vec->length; i > ind; i--) {
		vec->data[i] = vec->data[i - 1];
	}
	vec->data[ind] = val;
	vec->length += 1;
	return 1;
}

int erase(Vector *vec, int ind) {
	if (vec == NULL) return 0;
	if (ind < 0 || ind >= vec->length) return 0;
	for (int i = ind + 1; i < vec->length; i++) {
		vec->data[i - 1] = vec->data[i];
	}
	vec->length -= 1;
	return 1;
}

void output(Vector *vec) {
	printf("Vector : [");
	for (int i = 0; i < vec->length; i++) {
		i && printf(", ");
		printf("%d", vec->data[i]);
	}
	printf("]\n");
}

void clear(Vector *vec) {
	free(vec->data);
	free(vec);
	return ;
}

int main() {
	srand(time(0));
    #define max_op 20
	Vector *vec = init(max_op);
	for (int i = 0; i < max_op << 2; i++) {
		int op = rand() % 4;
		int ind = rand() % (vec->length + 3) - 1;
		int val = rand() % 100;
		switch (op) {
			case 0:
			case 1:
			case 2: {
				printf("insert %d at %d to Vector = %d\n", val, ind, insert(vec, ind, val));
			} break;
			case 3: {
				printf("erase a item at %d from Vector = %d\n", ind, erase(vec, ind));
			} break;
		}
		output(vec);
		printf("\n");
	}
	output(vec);
	clear(vec);
	#undef max_op
	return 0;
}

```



#   Second é“¾è¡¨

##  ç»“æ„å®šä¹‰

```c
Node:
data, *next;

List:
head, length
```



## ç»“æ„æ“ä½œ

###  æ’å…¥

```c
int insert(List *l, int ind, int val) {
	if (l == NULL) return 0;
	if (ind < 0 || ind > l->length) return 0;
	ListNode *p = &(l->head), *node = getNewNode(val);
	while (ind--) p = p->next;
	node->next = p->next;
	p->next = node;
	l->length += 1;
	return 1;
}
```



###  åˆ é™¤

```c
int erase(List *l, int ind) {
	if (l == NULL) return 0;
	if (ind < 0 || ind >= l->length) return 0;
	ListNode *p = &(l->head), *q;
	while (ind--) p = p->next;
	q = p->next;
	p->next = q->next;
	free(q);
	l->length -= 1;
	return 1;
}
```



###  å€’è½¬

```c
void reverse(List *l) {
	ListNode *p = l->head.next, *q;
	l->head.next = NULL;
	while (p) {
		q = p->next;
		p->next = l->head.next;
		l->head.next = p;
		p = q;
	}
	return ;
}
```



###  å¥½çœ‹æ»´è¾“å‡º

```c
void output1(List *l, int ind) {
	printf("head->");
	for (ListNode *p = l->head.next; p; p = p->next) {
		printf("%d->", p->data);
	}
	if (ind < 0 || ind > l->length) ind = -1;
	if (l == NULL) ind = -1;
	printf("NULL\n");
	for (int i = 0; i < 4 * (ind + 1) + 3; i++) {
		printf(" ");
	}
	printf("^\n");
	for (int i = 0; i < 4 * (ind + 1) + 3; i++) {
		printf(" ");
	}
	printf("|\n\n");
}
```



##  ä»£ç å®ç°

```c
#include<iostream>
#include<time.h>
using namespace std;

typedef struct ListNode {
	int data;
	struct ListNode *next;
} ListNode;

typedef struct List {
	ListNode head;
	int length;
} List;

ListNode *getNewNode(int);
List *getLinkList();
void clear_node(ListNode *);
void clear(List *);
int insert(List *, int, int);
int erase(List *, int);
void output(List *);
void output1(List *, int);
void reverse(List *);

int main() {
	srand(time(0));
	#define max_op 20
	List *l = getLinkList();
	int ind, op, val;
	for (int i = 0; i < max_op; i++) {
		op = rand() % 4;
		ind = rand() % (l->length + 3) - 1;
		cout << ind << endl;
		val = rand() % 100;
		switch (op) {
			case 0:
			case 1: {
				printf("insert %d at %d to list = %d\n", val, ind, insert(l, ind, val));
			} break;
			case 2: {
				printf("erase a item at %d fro, list = %d\n", ind, erase(l, ind));
			} break;
			case 3: {
				printf("reverse the list !\n");
				reverse(l);
			} break;
		}
		output1(l, ind);
	}
	clear(l);
	#undef max_op
	return 0;
}

ListNode *getNewNode(int val) {
	ListNode *p = (ListNode *)malloc(sizeof(ListNode));
	p->data = val;
	p->next = NULL;
	return p;
}

List *getLinkList() {
	List *l = (List *)malloc(sizeof(List));
	l->head.next = NULL;
	l->length = 0;
	return l;
}

int insert(List *l, int ind, int val) {
	if (l == NULL) return 0;
	if (ind < 0 || ind > l->length) return 0;
	ListNode *p = &(l->head), *node = getNewNode(val);
	while (ind--) p = p->next;
	node->next = p->next;
	p->next = node;
	l->length += 1;
	return 1;
}

int erase(List *l, int ind) {
	if (l == NULL) return 0;
	if (ind < 0 || ind >= l->length) return 0;
	ListNode *p = &(l->head), *q;
	while (ind--) p = p->next;
	q = p->next;
	p->next = q->next;
	free(q);
	l->length -= 1;
	return 1;
}

void reverse(List *l) {
	ListNode *p = l->head.next, *q;
	l->head.next = NULL;
	while (p) {
		q = p->next;
		p->next = l->head.next;
		l->head.next = p;
		p = q;
	}
	return ;
}

void output(List *l) {
	printf("list(%d) = [", l->length);
	for (ListNode *p = l->head.next; p; p = p->next) {
		printf("%d->", p->data);
	}
	printf("NULL]\n");
	return ;
}

void output1(List *l, int ind) {
	printf("head->");
	for (ListNode *p = l->head.next; p; p = p->next) {
		printf("%d->", p->data);
	}
	if (ind < 0 || ind > l->length) ind = -1;
	if (l == NULL) ind = -1;
	printf("NULL\n");
	for (int i = 0; i < 4 * (ind + 1) + 3; i++) {
		printf(" ");
	}
	printf("^\n");
	for (int i = 0; i < 4 * (ind + 1) + 3; i++) {
		printf(" ");
	}
	printf("|\n\n");
}

void clear_node(ListNode *node) {
	if (node == NULL) return ;
	free(node);
	return ;
}

void clear(List *l) {
	if (l == NULL) return ;
	ListNode *p = l->head.next, *q;
	while (p) {
		q = p->next;
		clear_node(p);
		p = q;
	}
	free(l);
	return ;
}

```



##  å…¶ä»–é“¾è¡¨

###  å•å‘å¾ªç¯é“¾è¡¨

- headæŒ‡å‘å°¾èŠ‚ç‚¹ï¼Œä¸ºäº†ä»å¤´æ’å…¥ç›´æ¥åˆ°ä½
- æ’å…¥index = max_ind + 1,ä½ç½®å’Œæ’å…¥ind=0ä¸€æ ·ï¼Œä½†æ˜¯è¦ç§»åŠ¨å¤´æŒ‡é’ˆ



###  åŒå‘é“¾è¡¨



###  åŒå‘å¾ªç¯é“¾è¡¨





#  Third é˜Ÿåˆ—

##  ç»“æ„å®šä¹‰

```c
length
head   // é˜Ÿé¦–ä¸‹æ ‡
tail   // ä»£æ’å…¥ä½ç½®ä¸‹æ ‡
data_type = xxx
```



##  ç»“æ„æ“ä½œ

###  å…¥é˜Ÿ

tail + 1

åˆ¤æ»¡ï¼štail == size

```c
int push(Queue *q, int val) {
	if (q == NULL) return 0;
	if (q->tail == q->size) return 0;
	q->data[q->tail++] = val;
	return 1;
}

```



å…¥é˜Ÿå­˜åœ¨å‡æº¢å‡ºç°è±¡

![image-20200620142843098](/home/waygu-beef/.config/Typora/typora-user-images/image-20200620142843098.png)

ä¸ºäº†è§£å†³å‡æº¢å‡ºï¼Œå¼•å‡ºå¾ªç¯é˜Ÿåˆ—

tail + 1

åˆ¤æ»¡ï¼šcnt == size

```c
int push(Queue *q, int val) {
	if (q == NULL) return 0;
	if (q->cnt == q->size) return 0;
	q->data[q->tail++] = val;
	if (q->tail == q->size) q->tail -= q->size;
	q->cnt += 1;
	return 1;
}
```



###  å‡ºé˜Ÿ

æ™®é€šé˜Ÿåˆ—ï¼šhead + 1

```c
int pop(Queue *q) {
	if (q == NULL) return 0;
	if (empty(q)) return 0;
	q->head++;
	return 1;
}
```

å¾ªç¯é˜Ÿåˆ—ï¼š(tail + 1) % size

```c
int pop(Queue *q) {
	if (q == NULL) return 0;
	if (empty(q)) return 0;
	q->head++;
	if (q->head == q->size) q->head -= q->size;
    // ä»£æ›¿è¾ƒæ…¢çš„%è¿ç®—
	q->cnt -= 1;
	return 1;
}
```



###  åˆ¤ç©º

```c
int empty (Queue *q) {
	return q->head == q->tail;
}
```



###  å–é˜Ÿé¦–

```c
int front(Queue *q) {
	return q->data[q->head];
}
```



##  ä»£ç å®ç°

```c
#include<iostream>
#include<stdlib.h>
#include<time.h>
using namespace std;

typedef struct Queue {
	int *data;
	int size, head, tail;
    // int cnt; (å¾ªç¯é˜Ÿåˆ—)
} Queue;

Queue *init(int n) {
	Queue *q = (Queue *)malloc(sizeof(Queue));
	q->data = (int *)malloc(sizeof(int) * n);
	q->size = n;
	q->head = q->tail = 0;
    // q->cnt = 0; (å¾ª)
	return q;
}

int front(Queue *q) {
	return q->data[q->head];
}

int empty (Queue *q) {
	return q->head == q->tail;
}

int push(Queue *q, int val) {
	if (q == NULL) return 0;
	if (q->tail == q->size) return 0;
	q->data[q->tail++] = val;
	return 1;
}

int pop(Queue *q) {
	if (q == NULL) return 0;
	if (empty(q)) return 0;
	q->head++;
	return 1;
}

void output(Queue *q) {
	printf("Queue : [");
	for (int i = q->head; i < q->tail; i++) {
		(i != q->head) && printf(", ");
		printf("%d", q->data[i]);
	}
/*
 *  	for (int i = q->head, j = 0; j < q->cnt; j++) {
 *		j && printf(", ");
 *		printf("%d", q->data[(i + j) % q->size]);
 *	}
 */
	printf("]\n");
	return ;
}

void clear(Queue *q) {
	if (q == NULL) return ;
	free(q->data);
	free(q);
	return ;
}

int main() {
	srand(time(0));
	#define max_op 20
	Queue *q = init(max_op);
	for (int i = 0; i < max_op; i++) {
		int val = rand() % 100;
		int op = rand() % 4;
		switch (op) {
			case 0:
			case 1:
			case 2: {
				printf("push %d to the Queue = %d\n", val, push(q, val));
			} break;
			case 3: {
				printf("pop %d from the Queue = %d\n", front(q), pop(q));
			} break;
		}
		output(q), printf("\n");
	}
	#undef max_op
	clear(q);
	return 0;

```



# Forth æ ˆ

##  æ€æƒ³å¼•å…¥

```c
                         å°æ‹¬å·åŒ¹é…
bool isVal(char *s) {
    int32_t lnum = 0;
    int32_t len = strlen(s);
    for (int32_t i = 0; i < len; i++) {
 		switch (s[i]) {
            case '(': ++lnum; break;
            case ')': --lnum; break;
            default : return false;
        }       
        if (lnum >= 0) continue;
        return false;
    }
    return lnum == 0;
}

// 7ã€8è¡Œç‰¹åˆ«åƒæ ˆçš„æ“ä½œ

æ€è€ƒï¼š
ï¼ˆï¼‰å¯ä»¥ç­‰ä»·ä¸ºä¸€ä¸ªå®Œæ•´äº‹ä»¶ï¼Œå·¦æ‹¬å·ç›¸å½“äºäº‹ä»¶çš„å¼€å§‹ï¼Œå³æ‹¬å·ç›¸å½“äºäº‹ä»¶ç»“æŸï¼Œæœ‰å§‹æœ‰ç»ˆäº‹ä»¶çš„å¯ä»¥ç”¨æ ˆ
ï¼ˆï¼ˆï¼‰ï¼‰è¡¨ç¤ºäº‹ä»¶çš„å®Œå…¨åŒ…å«ï¼Œå¯ä»¥ç”¨æ ˆ
```



##  ç»“æ„å®šä¹‰

```c
size
top   // æ ˆé¡¶å…ƒç´ 
data_type == xxx
```



##  ç»“æ„æ“ä½œ

###  å…¥æ ˆ

top++;

```c
int push(Stack *s, int val) {
	if (s == NULL) return 0;
	if (s->top + 1 == s->size) {
		printf("expand %s\n", expand(s) ? "success" : "failed");
	}
	s->data[++(s->top)] = val;
	return 1;
}
```



###  å‡ºæ ˆ

top--;

```c
int pop(Stack *s) {
	if (s == NULL) return 0;
	if (empty(s)) return 0;
	s->top--;
	return 1;
}
```



###  æ‰©å®¹

```c
int expand(Stack *s) {
	int *p;
	int extr_size = s->size;
	while (extr_size) {
		p = (int *)realloc(s->data, sizeof(int) * (s->size + extr_size));
		if (p) break;
		extr_size /= 2;
	}
	if (!extr_size) return 0;
	s->data = p;
	s->size += extr_size;
	return 1;
}
```



###  åˆ¤ç©º

```c
int empty(Stack *s) {
	return s->top == -1;
}
```



###  è¿”å›æ ˆé¡¶å…ƒç´ 

```c
int top(Stack *s) {
	return s->data[s->top];
}
```



##  ä»£ç å®ç°

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

typedef struct Stack {
	int *data;
	int top, size;
} Stack;

Stack *init(int);
void clear(Stack *);
int top(Stack *);
int empty(Stack *);
int push(Stack *, int);
int pop(Stack *);
void output(Stack *);
int expand(Stack *);

int main() {
	srand(time(0));
	#define max_op 2
	Stack *s = init(max_op);
	for (int i = 0; i < max_op + 20; i++) {
		int op = rand() % 4;
		int val = rand() % 100;
		switch (op) {
			case 0:
			case 1:
			case 2:
				printf("push %d to the stack = %d\n", val, push(s, val));
				break;
			case 3:
				printf("pop %d from the stack = %d\n", top(s), pop(s));
				break;
		}
		output(s), printf("\n");
	}
	clear(s);
	return 0;
}

Stack *init(int n) {
	Stack *s = (Stack *)malloc(sizeof(Stack));
	s->data = (int *)malloc(sizeof(int) * n);
	s->size = n;
	s->top = -1;
	return s;
}

int top(Stack *s) {
	return s->data[s->top];
}

int empty(Stack *s) {
	return s->top == -1;
}

int expand(Stack *s) {
	int *p;
	int extr_size = s->size;
	while (extr_size) {
		p = (int *)realloc(s->data, sizeof(int) * (s->size + extr_size));
		if (p) break;
		extr_size /= 2;
	}
	if (!extr_size) return 0;
	s->data = p;
	s->size += extr_size;
	return 1;
}

int push(Stack *s, int val) {
	if (s == NULL) return 0;
	if (s->top + 1 == s->size) {
		printf("expand %s\n", expand(s) ? "success" : "failed");
	}
	s->data[++(s->top)] = val;
	return 1;
}

int pop(Stack *s) {
	if (s == NULL) return 0;
	if (empty(s)) return 0;
	s->top--;
	return 1;
}

void output(Stack *s) {
	printf("Stack(%d) = [", s->size);
	for (int i = 0; i <= s->top; i++) {
		i && printf(", ");
		printf("%d", s->data[i]);
	}
	printf("]\n");
	return ;
}

void clear(Stack *s) {
	if (s == NULL) return ;
	free(s->data);
	free(s);
	return ;
}

```



###  3 tips

1. æ ˆå¯ä»¥è§£å†³å®Œå…¨åŒ…å«å…³ç³»
2. é€’å½’å€ŸåŠ©ç³»ç»Ÿæ ˆï¼Œç³»ç»Ÿæ ˆä¹Ÿæ˜¯æ ˆ
3. å‡½æ•°è°ƒç”¨ä½¿ç”¨æ ˆï¼Œæ¯”å¦‚ä¸»å‡½æ•°æ—¶ç¬¬ä¸€ä¸ªè¿›çš„æœ€åä¸€ä¸ªå‡ºçš„



#  Third + Forth

##  æ ˆå’Œé˜Ÿåˆ—çš„åº”ç”¨

| æ•°æ®ç»“æ„ | åº”ç”¨               |
| -------- | ------------------ |
| æ ˆ       | æ ‘çš„æ·±åº¦éå†ã€æ·±æœ |
| é˜Ÿåˆ—     | æ ‘çš„å±‚åºéå†ã€å¹¿æœ |
| å•è°ƒæ ˆ   | ä¸´è¿‘æœ€å¤§ï¼ˆå°ï¼‰å€¼   |
| å•è°ƒé˜Ÿåˆ— | åŒºé—´æœ€å¤§ï¼ˆå°ï¼‰å€¼   |



##  å•è°ƒæ ˆ

æœ€è¿‘å°äº/å¤§äºå…³ç³»ï¼šå¦‚æœæ‰¾å·¦å³ä¸¤è¾¹ç¬¬ä¸€ä¸ªæœ€å°çš„ï¼Œç»´æŠ¤é€’å¢æ ˆï¼Œæœ€å¤§çš„åä¹‹ï¼Œæ¯æ¬¡çš„ç­”æ¡ˆæ˜¯æ ˆä¸­å…¶å±è‚¡åº•ä¸‹çš„å…ƒç´ 

æŠ€å·§ï¼šæ ˆä¸­å­˜ä¸‹æ ‡ï¼ˆä¸‹æ ‡è®¿é—®æ•°ç»„å…ƒç´ æ˜“ï¼Œåè¿‡æ¥éš¾ï¼‰  é˜Ÿåˆ—åŒç†

OJ 264

264ï¼šSTLçš„stackï¼Œæœ€å¤§çŸ©å½¢é¢ç§¯

```c
                    å·¦å³ä¸¤è¾¹ç¬¬ä¸€ä¸ªæœ€å°
    arr[0] = arr[n + 1] = -1;         // æŠ€å·§ï¼šæŒ–ä¿©å‘æ ‡å¿—è¾¹ç•Œ
	for (long long i = 1; i <= n; i++) cin >> arr[i];
	s.push(0); 
	for (long long i = 1; i <= n; i++) {
		while (arr[s.top()] >= arr[i]) s.pop();
		l[i] = i - s.top();
		s.push(i);
	}
	while (!s.empty()) s.pop();
	s.push(n + 1);
	for (long long i = n; i >= 1; i--) {
		while (arr[s.top()] >= arr[i]) s.pop();
		r[i] = s.top() - i;
		s.push(i);
	}
	long long ans = 0;
	for (long long i = 1; i <= n; i++) {
		ans = max(ans, arr[i] * (r[i] + l[i] - 1));
	}
       
```



##  å•è°ƒé˜Ÿåˆ—

æ±‚åŒºé—´æœ€å¤§/æœ€å°å€¼ï¼šæœ€å¤§å€¼ç»´æŠ¤é€’å‡é˜Ÿåˆ—ï¼Œæœ€å°åä¹‹ï¼Œæ¯æ¬¡çš„ç­”æ¡ˆæ˜¯é˜Ÿé¦–ï¼Œè¶…è¿‡ç®¡è¾–èŒƒå›´çš„é˜Ÿé¦–å¼¹å‡º

OJ 271ã€270

271ï¼š ç”¨æ•°ç»„ä»¿é˜Ÿåˆ—ï¼Œæ»‘åŠ¨çª—å£

```c
[1 [3 -1 -3] 5 7 3 6]

					 æœ€å¤§å€¼
	for (int i = 0; i < n; i++) {
        while (tail - head && a[i] >= a[q[tail - 1]]) tail--;
        q[tail++] = i;
        if (i + 1 < k) continue;  // è¿˜æ²¡æ¯”è¾ƒå®Œæœ€å¼€å§‹çš„å‰kä¸ª
        if (i - q[head] == k) head++;	// è¶…è¿‡æ»‘åŠ¨çª—å£èŒƒå›´ï¼Œé˜Ÿé¦–æ‰”æ‰
        i + 1 == k || cout << ' ';
        cout << a[q[head]];
    }

```

270ï¼šç”¨æ•°ç»„ä»¿é˜Ÿåˆ—ï¼Œæœ€å¤§å­åºå’Œ

```c
[1 -3 5 1 -2 3] å‰ç¼€å’Œ [1 -2 3 4 2 5]

					å½“å‰å€¼å·¦ä¾§åŒºé—´æœ€å°å€¼
	for (int i = 1; i <= n; i++) {
		if (i - q[head] > m) head++;
		ans = max(ans, s[i] - s[q[head]]);
		while (tail - head && s[i] < s[q[tail - 1]]) tail--;
		q[tail++] = i;
	}

```





# Fifth æ ‘

ç‚¹ï¼šé›†åˆï¼Œè¾¹ï¼šå…³ç³»ï¼Œæ ¹ç»“ç‚¹ï¼šå…¨é›†ï¼Œä¸€è¡Œå–å¹¶ä¸ºå…¨é›†

æ ‘å’Œæ ˆä¸€æ ·ï¼Œå¯ä»¥è§£å†³ä¸€ç±»å…·æœ‰å®Œå…¨åŒ…å«å…³ç³»çš„é—®é¢˜ï¼Œæ ‘çš„éå†å°±æ˜¯å€ŸåŠ©ç³»ç»Ÿæ ˆ

##  ç»“æ„å®šä¹‰

```c
node:
data
*next[3] 3ï¼šä¸‰å‰æ ‘
```



##  åŸºæœ¬æ¦‚å¿µæ€§è´¨

æ·±åº¦ï¼šä»ä¸Šå‘ä¸‹çœ‹

é«˜åº¦ï¼šä»ä¸‹å¾€ä¸Šçœ‹ï¼Œå¯¹æ ‘æ¥è¯´ä¸€æ ·ï¼Œå¯¹ç»“ç‚¹ä¸åŒ

åº¦ï¼šå­å­©å­æ•°

èŠ‚ç‚¹æ•° = è¾¹æ•° + 1



##  

##  äºŒå‰æ ‘ï¼ˆäºŒè¿›åˆ¶ï¼‰

åº¦ä¸º0çš„èŠ‚ç‚¹æ¯”åº¦ä¸º2çš„èŠ‚ç‚¹å¤š1



###  å°†nå‰æ•°è¡¨ç¤ºæˆäºŒå‰æ ‘

å·¦å­©å­å³å…„å¼Ÿï¼Œåå­—é“¾è¡¨æ³•

nå‰æ•°ï¼šä¸ç¡®å®šæ€§é—®é¢˜ï¼ˆç»“æ„å®šä¹‰æ²¡æ³•å†™ï¼‰ï¼ŒäºŒå‰æ ‘ï¼šç¡®å®šé—®é¢˜ï¼Œè€Œè®¡ç®—æœºåªèƒ½è§£å†³ç¡®å®šæ€§é—®é¢˜ã€‚äºŒå‰æ ‘çš„æ„ä¹‰å°±æ˜¯ï¼Œä¸ç®¡å‡ å‰æ ‘éƒ½èƒ½ç”¨äºŒå‰æ ‘è¡¨ç¤º



###  éå†

å…ˆåºã€ä¸­åºã€ååº



###  ç‰¹æ®Š

å®Œå…¨äºŒå‰æ ‘

1. ç¼–å·ä¸ºiçš„èŠ‚ç‚¹ï¼Œå·¦èŠ‚ç‚¹:2 * iï¼Œå³èŠ‚ç‚¹:2 * i + 1
2. å¯ä»¥ç”¨è¿ç»­ç©ºé—´ï¼Œå³æ•°ç»„ï¼Œå€ŸåŠ©æ€§è´¨1å­˜å‚¨ã€‚è®°å½•å¼å˜æˆè®¡ç®—å¼



æ»¡äºŒå‰æ ‘ï¼šåªæœ‰åº¦ä¸º2å’Œ0çš„èŠ‚ç‚¹ï¼ˆå›½é™…ç‰ˆï¼‰

å®Œç¾äºŒå‰æ ‘ï¼šä¸­å›½ç‰ˆçš„æ»¡äºŒå‰æ ‘



### è¡¨ç¤ºæ–¹æ³•ï¼šå¹¿ä¹‰è¡¨

()

A(B, )

A(B, C)

è‡ªå·±è„‘è¡¥



### æ’åºäºŒå‰æ ‘

ä¸­åºéå†åˆ™æœ‰åº



##  ç»“æ„æ“ä½œ

### æ’å…¥ï¼ˆä»¥æ’åºäºŒå‰æ ‘çš„å½¢å¼ï¼‰

```c
Node *insert_node(Node *root, int val, int *flag) {
	if (root == NULL) {
		*flag = 1;
		return init_node(val);
	}
	if (root->data == val) return root;
	if (val < root->data) root->lchild = insert_node(root->lchild, val, flag);
	else root->rchild = insert_node(root->rchild, val, flag);
	return root;
}

void insert(Tree *tree, int val) {
	int flag = 0;
	tree->root = insert_node(tree->root, val, &flag);
	tree->n += flag;
	return ;
}
```



### è¾“å‡º

```c
void output_node(Node *root) {
	if (root == NULL) return ;
	printf("%d", root->data);
	if (root->lchild == NULL && root->rchild == NULL) return ;
	printf("(");
	output_node(root->lchild);
	printf(",");
	output_node(root->rchild);
	printf(")");
	return ;
}

void output(Tree *tree) {
	if (tree == NULL) return ;
	printf("Tree(%d) : ", tree->n);
	output_node(tree->root);
	printf("\n");
	return ;
}
```



### éå†

```c
                          ä¸­åº
void in_order_node(Node *root) {
	if (root == NULL) return ;
	in_order_node(root->lchild);
	printf("%d ", root->data);
	in_order_node(root->rchild);
	return ;
}

void in_order(Tree *tree) {
	if (tree == NULL) return ;
	printf("in_order : ");
	in_order_node(tree->root);
	printf("\n");
	return ;
}
```

```c
                          å…ˆåº
void pre_order_node(Node *root) {
	if (root == NULL) return ;
	printf("%d ", root->data);
	pre_order_node(root->lchild);
	pre_order_node(root->rchild);
	return ;
}

void pre_order(Tree *tree) {
	if (tree == NULL) return ;
	printf("pre_order : ");
	pre_order_node(tree->root);
	printf("\n");
	return ;
}
```

```c
                          ååº
void post_order_node(Node *root) {
	if (root == NULL) return ;
	post_order_node(root->lchild);
	post_order_node(root->rchild);
	printf("%d ", root->data);
	return ;
}

void post_order(Tree *tree) {
	if (tree == NULL) return ;
	printf("post_order : ");
	post_order_node(tree->root);
	printf("\n");
	return ;
}
```



##  ä»£ç å®ç°

```c
#include<iostream>
#include<stdlib.h>
#include<time.h>
using namespace std;

typedef struct Node {
	int data;
	struct Node *lchild, *rchild;
} Node;

typedef struct Tree {
	Node *root;
	int n;
} Tree;

Node *init_node(int val) {
	Node *p = (Node *)malloc(sizeof(Node));
	p->data = val;
	p->lchild = p->rchild = NULL;
	return p;
}

Tree *init_tree() {
	Tree *tree = (Tree *)malloc(sizeof(Tree));
	tree->root = NULL;
	tree->n = 0;
	return tree;
}

Node *insert_node(Node *root, int val, int *flag) {
	if (root == NULL) {
		*flag = 1;
		return init_node(val);
	}
	if (root->data == val) return root;
	if (val < root->data) root->lchild = insert_node(root->lchild, val, flag);
	else root->rchild = insert_node(root->rchild, val, flag);
	return root;
}

void insert(Tree *tree, int val) {
	int flag = 0;
	tree->root = insert_node(tree->root, val, &flag);
	tree->n += flag;
	return ;
}

void output_node(Node *root) {
	if (root == NULL) return ;
	printf("%d", root->data);
	if (root->lchild == NULL && root->rchild == NULL) return ;
	printf("(");
	output_node(root->lchild);
	printf(",");
	output_node(root->rchild);
	printf(")");
	return ;
}

void output(Tree *tree) {
	if (tree == NULL) return ;
	printf("Tree(%d) : ", tree->n);
	output_node(tree->root);
	printf("\n");
	return ;
}

void in_order_node(Node *root) {
	if (root == NULL) return ;
	in_order_node(root->lchild);
	printf("%d ", root->data);
	in_order_node(root->rchild);
	return ;
}

void in_order(Tree *tree) {
	if (tree == NULL) return ;
	printf("in_order : ");
	in_order_node(tree->root);
	printf("\n");
	return ;
}

void pre_order_node(Node *root) {
	if (root == NULL) return ;
	printf("%d ", root->data);
	pre_order_node(root->lchild);
	pre_order_node(root->rchild);
	return ;
}

void pre_order(Tree *tree) {
	if (tree == NULL) return ;
	printf("pre_order : ");
	pre_order_node(tree->root);
	printf("\n");
	return ;
}

void post_order_node(Node *root) {
	if (root == NULL) return ;
	post_order_node(root->lchild);
	post_order_node(root->rchild);
	printf("%d ", root->data);
	return ;
}

void post_order(Tree *tree) {
	if (tree == NULL) return ;
	printf("post_order : ");
	post_order_node(tree->root);
	printf("\n");
	return ;
}

void clear_node(Node *node) {
	if (node == NULL) return ;
	clear_node(node->lchild);
	clear_node(node->rchild);
	free(node);
	return ;
}

void clear(Tree * tree) {
	if (tree == NULL) return ;
	clear_node(tree->root);
	free(tree);
	return ;
}

int main() {
	srand(time(0));
	Tree *tree = init_tree();
	#define max_op 10
	for (int i = 0; i < max_op; i++) {
		int val = rand() % 100;
		insert(tree, val);
		output(tree);
	}
	pre_order(tree);
	post_order(tree);
	in_order(tree);
	#undef max_op
	clear(tree);
	return 0;
}
```





#  Six å“ˆå¤«æ›¼æ ‘

##  å®šé•¿ç¼–ç å’Œå¯å˜é•¿ç¼–ç 

å‡å¦‚å¸¦å®½æ˜¯100bit/s

ä¼ è¾“100ä¸ªå­—ç¬¦éœ€è¦8sï¼Œè€Œå¦‚æœåªæœ‰26ä¸ªè‹±æ–‡å­—æ¯ï¼Œéœ€è¦5ä½å³å¯ï¼Œåªæœ‰500ä¸ªå­—ç¬¦ï¼Œéœ€è¦5sï¼ˆ8ã€5ï¼šå®šé•¿ï¼‰

å¯å˜é•¿ï¼š100ä¸ªå­—ç¬¦ï¼Œè¿˜æ˜¯åªæœ‰26ä¸ªè‹±æ–‡å­—ç¬¦ï¼Œæœ‰99ä¸ªæ˜¯eï¼Œæœ‰ä¸€ä¸ªæ˜¯å…¶ä»–å­—ç¬¦ã€‚é‚£ä¹ˆå¯ä»¥ç»™eç¼–å·ä¸º0ï¼Œå…¶ä»–çš„ç¼–å·ä¸º1+5bitï¼Œè¿™æ ·å°±105ä¸ªå­—ç¬¦ï¼Œåªéœ€1.05sï¼Œå¾ˆä¼˜ç§€ã€‚

å¯å˜é•¿ç¼–ç åŸåˆ™ï¼šä¸€ä¸ªå­—ç¬¦çš„ç¼–ç ä¸€å®šä¸èƒ½æ˜¯å…¶ä»–å­—ç¬¦çš„ç¼–ç çš„å‰ç¼€ï¼ŒåŸå› è‡ªå·±çŒœ



## å“ˆå¤«æ›¼ç¼–ç 

### 3 tips

1. å“ˆå¤«æ›¼ç¼–ç æ˜¯ä¸€ç§å¯å˜é•¿ç¼–ç 
2. è¡¡é‡å‹ç¼©å¾—æœ‰å¤šä¼˜ç§€çš„æŒ‡æ ‡ï¼šå¹³å‡ç¼–ç é•¿åº¦
3. ç¼–ç é•¿åº¦æœŸæœ›ï¼šæ‰€æœ‰ å­—ç¬¦å‡ºç°æ¦‚ç‡ä¹˜ç¼–ç é•¿åº¦ æ±‚å’Œã€‚å®ƒå°±ä»£è¡¨å¹³å‡ç¼–ç é•¿åº¦ã€‚ä½¿å®ƒè¾¾åˆ°æœ€å°çš„ç¼–ç æ–¹æ³•å°±æ˜¯æœ€å¥½çš„ç¼–ç æ–¹æ³•



### ä¿¡æ¯ç†µ

æƒ³ä¸€æƒ³å››ä¸ªå­—ç¬¦å¯ä»¥å¦‚ä½•æ¶‚é»‘ç‚¹ï¼ˆç¼–ç ï¼‰

![image-20200628152713209](/home/waygu-beef/.config/Typora/typora-user-images/image-20200628152713209.png)

æ ‘é«˜ä¸ºhï¼Œè®¾æŸä¸ªèŠ‚ç‚¹åˆ°æ ¹ç»“ç‚¹çš„è·¯ç»é•¿åº¦ä¸ºlï¼ˆå³ç¼–ç é•¿åº¦ï¼‰ï¼Œåˆ™å¶å­èŠ‚ç‚¹æ•°ä¸º2^h^ï¼Œå½“å‰èŠ‚ç‚¹èƒ½è¦†ç›–å¶å­èŠ‚ç‚¹ä¸ªæ•°ä¸º2^h-l^

åº”è¯¥æ»¡è¶³å…¬å¼ï¼š2^h-l1^ + 2^h-l2^ + ..... 2^h-ln^  <= 2^h^   ï¼ˆ1ï¼‰



1. ==ä¼˜åŒ–ç›®æ ‡==ï¼šâˆ‘P~i~L~i~    (min)

   Pä¸ºå·²çŸ¥é‡ï¼ŒLä¸ºæœªçŸ¥é‡ï¼Œå¼ï¼ˆ1ï¼‰æ˜¯Lçš„ä¸€ä¸ª==çº¦æŸæ¡ä»¶==



2. å…¬å¼å˜å½¢ï¼š1/2^l1^ + 1/2^l2^ + ... + 1/2^ln^ <= 1 

   ä»¤-l~i~ ä¸ºl~i~'ï¼Œ==ä¼˜åŒ–ç›®æ ‡==å˜ä¸º-âˆ‘P~i~L~i~â€˜ï¼Œ==çº¦æŸæ¡ä»¶==å˜ä¸ºâˆ‘2^Li'^ <= 1

   

3. ä»¤Y~i~ = 2 * l~i~'    L~i~' = log~2~Y~i~

   ==ä¼˜åŒ–ç›®æ ‡==ï¼š-âˆ‘P~i~log~2~Y~i~ ï¼Œ==çº¦æŸæ¡ä»¶==ï¼šâˆ‘Y~i~ <= 1

   

4. å½“âˆ‘Y~i~ = 1æ—¶ï¼Œâˆ‘P~i~log~2~Y~i~æœ€å¤§ï¼Œ-âˆ‘P~i~log~2~Y~i~æœ€å°ï¼Œè¯æ˜ç”¨åè¯æ³•ï¼Œè‡ªå·±è¯



5. ä»¤Y~n~ = 1 - YY

   ä¼˜åŒ–ç›®æ ‡ï¼š-âˆ‘P~i~log~2~Y~i~ ï¼ˆiä»1ï½n - 1ï¼‰  + P~n~log~2~(1 - YY)

   

   å¯¹Y~1~...Y~n-1~æ±‚åå¯¼
   
   P~1~ / (Y~1~ * ln2) - P~n~ / ((1 - YY) * ln2) = 0
   
   P~2~ / (Y~2~ * ln2) - P~n~ / ((1 - YY) * ln2) = 0
   
   â€¦â€¦
   
   P~n-1~ / (Y~n-1~ * ln2) - P~n~ / ((1 - YY) * ln2) = 0
   
   æ¨å‡º
   
   P~1~ / (Y~1~ * ln2) = P~2~ / (Y~2~ * ln2) = ... = P~n-1~ / (Y~n-1~ * ln2)
   
   P~1~ / Y~1~ = P~2~ / Y~2~ = ... = P~n-1~ / Y~n-1~ =  P~n~ / Y~n~ 
   
   å› ä¸º
   
   P~1~ + P~2~ + ... + P~n~ = 1
   
   Y~1~ + Y~2~ + ... + Y~n~ = 1
   
   æ¨å‡º
   
   P~1~ = Y~1~, P~2~ = Y~2~, ... , P~n~ = Y~n~
   
   å³
   
   P~i~ = Y~i~

â€‹	

ä¼˜åŒ–ç›®æ ‡ï¼š-âˆ‘P~i~log~2~Y~i~  =  -âˆ‘P~i~log~2~P~i~   <--è¿™å°±æ˜¯ç†µå…¬å¼

å…¬å¼åæ˜ çš„æ€§è´¨ï¼šæ¦‚ç‡è¶Šå¤§ï¼Œæ‰€ç”¨ç¼–ç é•¿åº¦è¶ŠçŸ­

äº¤å‰ç†µæ˜¯æ¯”è¾ƒä¸¤ç»„æ¦‚è®ºåºåˆ—æ··ä¹±ç¨‹åº¦çš„ç›¸ä¼¼åº¦

(P1, P2, .. Pn)

(q1, q2, .. qn)



â€‹	-âˆ‘P~i~log~2~P~i~  æ¢æˆ  -âˆ‘P~i~log~2~Q~i~ï¼Œ-âˆ‘P~i~log~2~Q~i~è¶Šå°ï¼Œä¸¤ç»„æ¦‚è®ºåºåˆ—æ··ä¹±ç¨‹åº¦è¶Šç›¸ä¼¼ï¼ˆæŸ¥é˜…çŸ¥è¯†é‡æ–°æ•´ç†ï¼‰



### å“ˆå¤«æ›¼ç¼–ç å’Œå“ˆå¤«æ›¼æ ‘

P~i~è¶Šå¤§ï¼Œè¦æƒ³æ•´ä½“è¶Šå°ï¼ŒY~i~è¶Šå¤§ï¼ŒL~i~è¶Šå°ï¼Œå³é¢‘ç‡è¶Šå¤§è·¯å¾„é•¿åº¦è¶Šå°

æˆ‘ä»¬çŸ¥é“ï¼Œå¯å˜é•¿ç¼–ç çš„ç‰¹æ€§æ˜¯ä¸€ä¸ªå­—ç¬¦çš„ç¼–ç ä¸€å®šä¸èƒ½æ˜¯å…¶ä»–å­—ç¬¦çš„ç¼–ç çš„å‰ç¼€

å“ˆå¤«æ›¼ç¼–ç å’Œå“ˆå¤«æ›¼æ ‘ï¼Œæ€ä¹ˆæ¥çš„ï¼ˆçœ‹è§†é¢‘æ•´ç†ï¼‰

åªä»¥äºŒå‰æ ‘çš„å¶å­èŠ‚ç‚¹åšç¼–ç 



# Seven çº¿ç´¢åŒ–äºŒå‰æ ‘

äºŒå‰æ ‘éå†ä½¿ç”¨é€’å½’æŠ€å·§çš„åŸå› ï¼šæœ‰å›æº¯è¿‡ç¨‹ï¼Œå¦‚ä¸‹å›¾ä»2åˆ°1

è§£å†³äºŒå‰æ ‘çˆ†æ ˆï¼šé€’å½’->éé€’å½’

â€‹		1. è§£å†³å›æº¯è¿‡ç¨‹

â€‹		2. ä¸€ä¸ªèŠ‚ç‚¹æœ‰ä¸¤ä¸ªæŒ‡é’ˆåŸŸï¼Œå…±2nä¸ªæŒ‡é’ˆåŸŸï¼Œè€Œè¾¹æœ‰n - 1ä¸ªï¼Œæ²¡æœ‰å®é™…ä½œç”¨çš„æŒ‡é’ˆåŸŸæœ‰n + 1ä¸ªï¼Œæˆ‘ä»¬è€ƒè™‘æŠŠè¿™n + 1ä¸ªæŒ‡é’ˆåŸŸç©ºé—´åˆ©ç”¨ä¸Š



1. æ·»åŠ 2çš„åç»§ä¸º1ï¼ˆä¸€æ¡çº¿ç´¢ï¼‰(ä¸­åºéå†)

   <img src="/home/waygu-beef/.config/Typora/typora-user-images/image-20200630185657465.png" alt="image-20200630185657465" style="zoom:33%;" />

   éœ€è¦ltagå’Œrtagæ ‡è®°è¿™ä¸ªèŠ‚ç‚¹çš„å­©å­æ˜¯çœŸå­©å­è¿˜æ˜¯çº¿ç´¢

2. ä¸­åºéå†ï¼ˆBDAECï¼‰çš„å‰é©±å’Œåç»§

<img src="/home/waygu-beef/.config/Typora/typora-user-images/image-20200630191348763.png" alt="image-20200630191348763" style="zoom: 33%;" />

```c

```



# Eight å †å’Œä¼˜å…ˆé˜Ÿåˆ—

## 

## 

## ç»“æ„æ€§è´¨

å¤§é¡¶å †ï¼šå®Œå…¨äºŒå‰æ ‘ + ä»»æ„ä¸€ä¸ªå°ä¸‰è§’è„‘ç“œå¸¦æœ€å¤§

å°é¡¶å †ï¼šå®Œå…¨äºŒå‰æ ‘ + ä»»æ„ä¸€ä¸ªå°ä¸‰è§’è„‘ç“œå¸¦æœ€å°



## ç»“æ„æ“ä½œï¼šç»´æŠ¤ç»“æ„æ€§è´¨

æ‹¿å¤§é¡¶å †ä¸¾ä¾‹

#### å…¥å †

æ”¾åœ¨å®Œå…¨äºŒå‰æ ‘æœ€åï¼Œç„¶åä»ä¸‹å‘ä¸Šç»´æŠ¤

```c
int push(priority_queue *q, int val) {
	if (q == NULL) return 0;
	if (q->cnt == q->size) return 0;
	q->data[++(q->cnt)] = val;
	int ind = q->cnt;
	while (ind >> 1 && q->data[ind] > q->data[ind >> 1]) {
		swap(q->data[ind], q->data[ind >> 1]);
		ind >>= 1;
	}
	return 1;
}
```



####  å‡ºå †

å †é¦–å †å°¾äº¤æ¢ï¼Œç„¶åä»ä¸Šå¾€ä¸‹ç»´æŠ¤

```c
int pop(priority_queue *q) {
	if (q == NULL) return 0;
	if (empty(q)) return 0;
	q->data[1] = q->data[q->cnt--];
	int ind = 1;
	while ((ind << 1) <= q->cnt) {
		int temp = ind, l = ind << 1, r = ind << 1 | 1;
		if (q->data[l] > q->data[temp]) temp = l;
		if (r <= q->cnt && q->data[r] > q->data[temp]) temp = r;
		if (temp == ind) break;
		swap(q->data[ind], q->data[temp]);
		ind = temp;
	}
	return 1;
}
```



####  å †æ’åº

æ¯æ¬¡æŠŠå †å¤´å’Œå †å°¾äº¤æ¢ï¼Œå€¼æœ€å¤§çš„æ¨å¤´è¢«æ”¾åœ¨æ•°ç»„åå¤´ï¼Œéƒ½å‡ºæ¨åï¼Œç»“æœä¸ºä¸€ä¸ªå…ƒç´ ä»å°åˆ°å¤§çš„æ•°ç»„



##  ä¼˜å…ˆé˜Ÿåˆ—

å †ç§°ä¸ºä¼˜å…ˆé˜Ÿåˆ—çš„åŸå› ï¼šæ“ä½œåƒé˜Ÿåˆ—ã€æ¯æ¬¡å‡ºå †çš„æ˜¯æœ€å¤§æˆ–æœ€å°å…ƒç´ 

![image-20200704145941731](/home/waygu-beef/.config/Typora/typora-user-images/image-20200704145941731.png)



## å»ºå †

æ­£å¸¸å»ºå †å¤æ‚åº¦ï¼šO(nlogn)

ä¼˜åŒ–ï¼šçº¿æ€§å»ºå †



# Ninth æ’åº

##  å„ç§æ’åºæ¦‚è¿°

åˆ†ç±»ï¼šç¨³å®š/éç¨³å®šã€å†…éƒ¨æ’åº/å¤–éƒ¨æ’åºã€æ—¶é—´å¤æ‚åº¦

ç¨³å®šçš„ï¼š



1. æ’å…¥æ’åºï¼šå·²æ’åºåŒº | æœªæ’åºåŒºï¼Œæ¯è½®æœªæ’å¥½åºä¸­æœ€å‰é¢çš„å…ƒç´ å¾€å‰ä¸€ä¸ªä¸€ä¸ªæ‹±åˆ°è‡ªå·±è¯¥å‘†çš„åœ°æ–¹
2. å†’æ³¡æ’åºï¼šæœªæ’åºåŒº | å·²æ’åºåŒºï¼Œå½“å‰æœªæ’åºéƒ¨åˆ†æœ€å¤§/æœ€å°å€¼æ³¢æ³¢æ³¢æ³¢å¾€åå†’
3. 2/kè·¯å½’å¹¶ï¼šåŠˆå¼€å†åŠˆå¼€ï¼Œ2ä¸ªæœ‰åºçš„åºåˆ—åˆå¹¶æˆä¸€ä¸ªå¤§æœ‰åºåºåˆ—

éç¨³å®šçš„ï¼š

1. é€‰æ‹©æ’åºï¼šå·²æ’åºåŒº | æœªæ’åºåŒºï¼Œæœªæ’åºå»é€‰ä¸€ä¸ªæœ€å¤§/æœ€å°çš„æ‰”åœ¨å·²æ’åºåŒºå°¾éƒ¨
2. å¿«é€Ÿæ’åºï¼šç¬¬ä¸€ä¸ªæ•°æ˜¯åŸºå‡†ï¼Œä¸€ä¸ªå¤´æŒ‡é’ˆï¼Œä¸€ä¸ªå°¾æŒ‡é’ˆï¼Œä½™ä¸‹éš¾ä»¥æè¿°ï¼Œå¦‚å›¾



##  å…³äºå†…éƒ¨å¤–éƒ¨æ’åº

å½’å¹¶æ’åºæ˜¯å¤–éƒ¨æ’åº

ğŸŒ°ï¼šä½ çš„ç”µè„‘å†…å­˜æœ‰4ä¸ªGï¼Œè€æ¿ç»™äº†ä½ ä¸€ç»„æ•°æ®å«ä½ æ’åºï¼Œè¿™ç»„æ•°æ®æœ‰80Gï¼Œæ€ä¹ˆæ’ï¼Ÿ

4ä¸ªG4ä¸ªGæ•´è¿‡æ¥æ’åºï¼Œç„¶å20ä¸ªæŒ‡é’ˆæŒ‡å‘20ä¸ªç»„ï¼Œå¯¹è¿™äº›æŒ‡é’ˆæŒ‡å‘çš„å€¼ç»´æŠ¤ä¸€ä¸ªå°é¡¶å †ï¼ˆåœ¨å†…å­˜ï¼‰ï¼Œæ•´ä½“å°±æ˜¯20è·¯å½’å¹¶çš„æ„ä¸º



##  ä¸åŒæ’åºçš„ä»£ç 

###  æµ‹è¯•æ’åºç»“æœå®

```c
#define TEST(arr, n, func, args...) { \
	int *num = (int *)malloc(sizeof(int) * n); \
	memcpy(num, arr, sizeof(int) * n); \
	output(num, n); \
	printf("%s = ", #func); \
	func(args); \
	output(num, n); \
	free(num); \
}

int main() {
	TEST(arr, max_op, insert_sort, num, max_op);
	TEST(arr, max_op, bubble_sort, num, max_op);
	TEST(arr, max_op, merge_sort, num, 0, max_op - 1);
}

```



### ç¨³å®šçš„

```c
                       æ’å…¥
void insert_sort(int *num, int n) {
	for (int i = 1; i < n; i++) {
		for (int j = i; j > 0 && num[j] < num[j - 1]; j--) {
			swap(num[j], num[j - 1]);
		}
	}
	return ;
}

```



```c
                       å†’æ³¡
void bubble_sort(int *num, int n) {
	int times = 1;
	for (int i = 1; i < n && times; i++) {
		times = 0;
		for (int j = 0; j < n - i; j++) {
			if (num[j] <= num[j + 1]) continue;
			swap(num[j], num[j + 1]);
			times++;
		}
	}
	return ;
}
                           
```



```c
                       å½’å¹¶
void merge_sort(int *num, int l, int r) {
	if (r - l <= 1) {
		if (r - l == 1 && num[r] < num[l]) {
			swap(num[l], num[r]);
		}
		return ;
	}
	int mid = (l + r) >> 1;
	merge_sort(num, l, mid);
	merge_sort(num, mid + 1, r);
	int *temp = (int *)malloc(sizeof(int) * (r - l + 1));
	int p1 = l, p2 = mid + 1, k = 0;
	while (p1 <= mid || p2 <= r) {
		if (p2 > r || (p1 <= mid && num[p1] <= num[p2])) {
			temp[k++] = num[p1++];
		} else {
			temp[k++] = num[p2++];
		}
	}
	memcpy(num + l, temp, sizeof(int) * (r - l + 1));
	free(temp);
	return ;
}
```





### ä¸ç¨³å®šçš„

```c
                     é€‰æ‹©æ’åº
void select_sort(int *num, int n) {
	for (int i = 0; i < n - 1; i++)	{
		int ind = i;
		for (int j = i + 1; j < n; j++) {
			if (num[ind] > num[j]) ind = j;
		}
		swap(num[i], num[ind]);
	}
	return ;
}

```



```c
                      å¿«é€Ÿæ’åº
void quick_sort(int *num, int l, int r) {
	if (l > r) return ;
	int x = l, y = r, z = num[l];
	while (x < y) {
		while (x < y && num[y] > z)	--y;
		if (x < y) num[x++] = num[y];
		while (x < y && num[x] < z) ++x;
		if (x < y) num[y--] = num[x];
	}
	num[x] = z;
	quick_sort(num, l, x - 1);
	quick_sort(num, x + 1, r);
	return ;
}

```



####  å¿«æ’ä¼˜åŒ–

å¿«æ’åœ¨é€†åºçš„æ—¶å€™ï¼Œå¤æ‚åº¦é€€åŒ–ä¸ºO(n^2^)ï¼Œéœ€è¦ä¼˜åŒ–ï¼šæ”¹å˜åŸºå‡†

ä¼˜åŒ–ç¨‹åºï¼Œä½¿ç¨³å®šåœ¨O(nlogn)

```c
#include<stdio.h>
#define max_n 100000
#define swap(a, b) { \
	__typeof(a) tmp = a; \
	a = b, b = tmp; \
}

void quick_sort(int *num, int l, int r) {
	while (l < r) {
		int x = l, y = r, z = num[(l + r) / 2];
		do {
			while (x <= y && num[x] < z) x++;
			while (x <= y && num[y] > z) y--;
			if (x <= y) {
				swap(num[x], num[y]);
				x++;
				y--;
			}
		} while (x <= y);
		quick_sort(num, x, r);
		r = y;
	}
}

int arr[max_n];

//åˆå§‹åŒ–ä¸€ä¸ªé€†åºæ•°ç»„
void init_arr(int *num, int n) {
	for (int i = 0; i < n; i++) num[i] = n - i;
	return ;
}

void output(int *num, int n) {
	for (int i = 0; i < n; i++) {
		printf("%d\n", num[i]);
	}
	return ;
}

int main() {
	init_arr(arr, max_n);
	quick_sort(arr, 0, max_n - 1);
	output(arr, max_n);
	return 0;
}

```

æ— ä¼˜åŒ–

```c
void quick_sort(int *num, int l, int r) {
	if (l > r) return ;
	int x = l, y = r, z = num[l];
	while (x < y) {
		while (x < y && num[y] > z)	--y;
		if (x < y) num[x++] = num[y];
		while (x < y && num[x] < z) ++x;
		if (x < y) num[y--] = num[x];
	}
	num[x] = z;
	quick_sort(num, l, x - 1);
	quick_sort(num, x + 1, r);
	return ;
}

```



ç»“æœæ¯”å¯¹

![image-20200705183707767](/home/waygu-beef/.config/Typora/typora-user-images/image-20200705183707767.png)





#  Tenth æŸ¥æ‰¾

##  äºŒåˆ†æŸ¥æ‰¾å’Œä¸‰åˆ†æŸ¥æ‰¾

### äºŒåˆ†æŸ¥æ‰¾

äºŒåˆ†æŸ¥æ‰¾ï¼Œéœ€è¦ä¸€ä¸ªæŸ¥æ‰¾å€¼ã€è¿”å›ä¸‹æ ‡çš„æ˜ å°„å…³ç³»ï¼Œå¯ä»¥ä½¿ç”¨æ•°ç»„ï¼Œè€Œå‡½æ•°æ˜¯å‹ç¼©çš„æ•°ç»„ï¼Œæ›´é«˜çº§çš„åšæ³•æ˜¯ä¼ å‡½æ•°æŒ‡é’ˆ

ä¸¤ç§åº”ç”¨ï¼š

å°±æ˜¯1ã€0é—®é¢˜ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ª/æœ€åä¸€ä¸ªæ»¡è¶³æƒ…å†µçš„å€¼

1ï¼šæ»¡è¶³æ¡ä»¶çš„å€¼

0ï¼šä¸æ»¡è¶³æ¡ä»¶çš„å€¼

1. 111111111100000000  æ‰¾æœ€åä¸€ä¸ª1

   mid = (min + max) >> 1

   arr[mid] == 1 min = mid

   arr[mid] != 1 max = mid - 1

   min == maxï¼Œå¤§æ¦‚ç‡ä¸Šæ‰¾åˆ°ç»“æœ â€”â€” å­˜åœ¨å…¨0æƒ…å†µ

   è¿™å°±éœ€è¦è®©minè™šæ‹Ÿå¤´æŒ‡é’ˆä¸€å¼€å§‹æŒ‡å‘æ•°ç»„-1ä½ç½®

   ```c
   int binary_search1(int *num, int n) {
   	int head = -1, tail = n - 1, mid;
   	while (head < tail) {
   		mid = (head + tail + 1) >> 1;
   		if (num[mid] == 1) head = mid;
   		else tail = mid - 1;
   	}
   	return head;
   }
   ```

   

2.    000000001111111111  æ‰¾ç¬¬ä¸€ä¸ª1

   mid = (min + max + 1) >> 1

   arr[mid] == 1 min = mid + 1

   arr[mid] != 1 max = mid

   min == maxï¼Œå¤§æ¦‚ç‡ä¸Šæ‰¾åˆ°ç»“æœ â€”â€” å­˜åœ¨å…¨0æƒ…å†µ

   åŒä¸Šå°†æœ€åä¸€ä½è®¾ç½®ä¸ºè™šæ‹Ÿä½ï¼Œè®©maxæŒ‡å‘è™šæ‹Ÿä½

   æœ€ååˆ¤æ–­è¿”å›çš„å¦‚æœæ˜¯è™šæ‹Ÿä½ï¼Œåˆ™æœªæ‰¾åˆ°1

```c
int binary_search2(int *num, int n) {
	int head = 0, tail = n, mid;
	while (head < tail) {
		mid = (head + tail) >> 1;
		if (num[mid] == 1) tail = mid;
		else head = mid + 1;
	}
	return head == n ? -1 : head;
}
```



### ä¸‰åˆ†æŸ¥æ‰¾

è§£å†³å‡¹å‡¸å‡½æ•°æå€¼ç‚¹é—®é¢˜

![image-20200705191447778](/home/waygu-beef/.config/Typora/typora-user-images/image-20200705191447778.png)



æ¯æ¬¡å°†é—®é¢˜åŒºé—´æ’é™¤ç¼©å°1 / 3ï¼ŒäºŒåˆ†æŸ¥æ‰¾æ•ˆç‡æ›´é«˜



## å“ˆå¸Œè¡¨

æ•°ç»„ï¼šæ˜ å°„å…³ç³»ï¼šä¸‹æ ‡è®¿é—®å€¼O(1)

å“ˆå¸Œè¡¨ï¼šæ˜ å°„å…³ç³»ï¼ˆä»»æ„ç±»å‹ï¼‰ï¼šæŸ¥æ‰¾å€¼O(1)

### å“ˆå¸Œå‡½æ•°

è§£å†³å€¼æ˜ å°„é—®é¢˜ï¼Œ é’ˆå¯¹ä¸åŒæ•°æ®ç±»å‹çš„ä¼˜ç§€å“ˆå¸Œå‡½æ•°æœ‰å¾ˆå¤š

### å†²çªå¤„ç†

è§£å†³å†²çªé—®é¢˜

1. å¼€æ”¾å®šå€¼ å äº†æŒªä¸‹ä¸€ä¸ª
2. æ‹‰é“¾æ³• å†²çªçš„åœ¨å®ƒè¯¥åœ¨çš„ä½ç½®æ‹‰ä¸ªé“¾å­
3. å†å“ˆå¸Œ å¦ä¸€ä¸ªå“ˆå¸Œå‡½æ•°
4. å»ºç«‹å…¬å…±æº¢å‡ºåŒº äº§ç”Ÿå†²çªçš„å€¼å†è¿™é‡Œå­˜å‚¨





# Eleventh äºŒå‰æ’åºæ ‘

åˆ«åï¼šäºŒå‰æ’åºæ ‘ã€äºŒå‰æœç´¢æ ‘

æ€§è´¨ï¼šå·¦å­æ ‘ < æ ¹èŠ‚ç‚¹  å³å­æ ‘ > æ ¹èŠ‚ç‚¹ï¼ˆå®šä¹‰ä¸€ä¸ªæ€§è´¨ï¼‰

ç”¨é€”ï¼šè§£å†³ä¸æ’åç›¸å…³çš„æ£€ç´¢éœ€æ±‚



## ç»“æ„æ“ä½œ

- æ’å…¥ï¼ˆç»´æŠ¤äºŒå‰æ’åºæ ‘çš„æ€§è´¨ï¼‰

- åˆ é™¤ 

  1. åˆ é™¤å¶å­èŠ‚ç‚¹

  2. åˆ é™¤åº¦ä¸º1çš„èŠ‚ç‚¹  

     è¯¥ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹æŒ‡å‘è¯¥èŠ‚ç‚¹çš„å­èŠ‚ç‚¹

     æˆ–è¯¥ç»“ç‚¹çš„å€¼èµ‹ç»™å”¯ä¸€å­èŠ‚ç‚¹ï¼ˆæ˜¯å¶å­ç»“ç‚¹ï¼‰

  3. åˆ é™¤åº¦ä¸º2çš„èŠ‚ç‚¹

     æ‰¾ï¼ˆä¸­åºéå†çš„ï¼‰å‰é©±æˆ–åç»§æ›¿æ¢å½“å‰èŠ‚ç‚¹ï¼Œè½¬æ¢ä¸ºåˆ é™¤åº¦ä¸º1æˆ–0çš„èŠ‚ç‚¹é—®é¢˜







# TWELVE å¹³è¡¡äºŒå‰æ ‘

AVLæ ‘

é¿å…æ’åºäºŒå‰æ ‘é€€åŒ–æˆé“¾è¡¨

é«˜åº¦ä¸ºHçš„æ’åºäºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹èŒƒå›´ä¸ºHåˆ°2^H^ - 1,è€Œå¹³è¡¡äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹èŒƒå›´ä¸º1.5^H^ + 1 åˆ° 2^H^ - 1

æ¨å¯¼è¿‡ç¨‹   å¦‚ç…§ç‰‡





å·¦å³æ—‹ï¼šæ¨å¯¼     å®Œäº†ä¹‹åè¿˜æ˜¯æ’åºäºŒå‰æ ‘ï¼Œæ—‹äº†ä¹‹åå¹³è¡¡





SBTreeè‡ªå·±çœ‹